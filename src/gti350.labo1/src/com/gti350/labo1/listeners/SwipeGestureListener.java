package com.gti350.labo1.listeners;

import android.util.Log;
import android.view.GestureDetector;
import android.view.MotionEvent;

/**
 * Gesture detector for a previous/next swipe detector.
 * 
 * @author Laurianne Michaud, Simon Turcotte-Langevin
 */
public class SwipeGestureListener extends GestureDetector.SimpleOnGestureListener {
	/** The logging tag to quickly identify logs generated by this class. */
	private static final String LoggingTag = SwipeGestureListener.class.getName();

	/** The swipe listener for a swipe that happened from left to right. */
	private IOnSwipeListener leftToRightListener;
	/** The swipe listener for a swipe that happened from right to left. */
	private IOnSwipeListener rightToLeftListener;
	/** The swipe listener for a swipe that happened from bottom to top. */
	private IOnSwipeListener bottomToTopListener;
	/** The swipe listener for a swipe that happened from top to bottom. */
	private IOnSwipeListener topToBottomListener;

	/**
	 * Empty constructor.
	 */
	public SwipeGestureListener() {
		this(null, null);
	}

	/**
	 * Constructor.
	 * 
	 * @param leftToRightListener
	 *            The swipe listener for a swipe that happened from left to
	 *            right.
	 * @param rightToLeftListener
	 *            The swipe listener for a swipe that happened from right to
	 *            left.
	 */
	public SwipeGestureListener(IOnSwipeListener leftToRightListener, IOnSwipeListener rightToLeftListener) {
		this(leftToRightListener, rightToLeftListener, null, null);
	}

	/**
	 * Constructor.
	 * 
	 * @param leftToRightListener
	 *            The swipe listener for a swipe that happened from left to
	 *            right.
	 * @param rightToLeftListener
	 *            The swipe listener for a swipe that happened from right to
	 *            left.
	 * @param bottomToTopListener
	 *            The swipe listener for a swipe that happened from bottom to
	 *            top.
	 * @param topToBottomListener
	 *            The swipe listener for a swipe that happened from top to
	 *            bottom.
	 */
	public SwipeGestureListener(IOnSwipeListener leftToRightListener, IOnSwipeListener rightToLeftListener, IOnSwipeListener bottomToTopListener,
			IOnSwipeListener topToBottomListener) {
		this.leftToRightListener = leftToRightListener;
		this.rightToLeftListener = rightToLeftListener;
		this.bottomToTopListener = bottomToTopListener;
		this.topToBottomListener = topToBottomListener;
	}

	@Override
	public boolean onFling(MotionEvent event1, MotionEvent event2, float velocityX, float velocityY) {
		boolean flingHandled = false;

		// Get then angle between the x-axis and the movement vector.
		float dx = event2.getX() - event1.getX();
		float dy = event2.getY() - event1.getY();
		float relativeAngle = getNormalVectorsRelativeAngle(dx, dy);

		if (relativeAngle < 45) {
			// Swipe was either from left to right or right to left.
			if (dx >= 0) {
				// Swiped from left to right.
				flingHandled = leftToRightListener != null && leftToRightListener.onSwipe(event1, event2, velocityX, velocityY);
				Log.i(LoggingTag, String.format("Left to right swipe detected. dx: %f, dy: %f.", dx, dy));
			} else if (dx < 0) {
				// Swiped from right to left.
				flingHandled = rightToLeftListener != null && rightToLeftListener.onSwipe(event1, event2, velocityX, velocityY);
				Log.i(LoggingTag, String.format("Right to left swipe detected. dx: %f, dy: %f.", dx, dy));
			}
		} else {
			// Swipe was either from bottom to top or top to bottom.
			if (dy >= 0) {
				// Swiped from bottom to top.
				flingHandled = bottomToTopListener != null && bottomToTopListener.onSwipe(event1, event2, velocityX, velocityY);
				Log.i(LoggingTag, String.format("Bottom to top swipe detected. dx: %f, dy: %f.", dx, dy));
			} else if (dy < 0) {
				// Swiped from top to bottom.
				flingHandled = topToBottomListener != null && topToBottomListener.onSwipe(event1, event2, velocityX, velocityY);
				Log.i(LoggingTag, String.format("Top to bottom swipe detected. dx: %f, dy: %f.", dx, dy));
			}
		}

		return flingHandled;
	}

	/**
	 * Return the angle, relative to the positive x-axis, of a line that passes
	 * by (0, 0) and (|dx|, |dy|). The angle is calculated counter clockwise
	 * from positive x-axis, in degrees. The value can be between 0 and 90.
	 * 
	 * @param dx
	 *            The difference, on the x axis, between two x values.
	 * @param dy
	 *            The difference, on the y axis, between two y values.
	 * @return The angle between the vector of this velocity, and the x axis.
	 */
	private float getNormalVectorsRelativeAngle(float dx, float dy) {
		float normalVectorsRelativeAngle = 0;
		if (dx == 0) {
			// atan would be NaN if velocityX = 0.
			normalVectorsRelativeAngle = 90;
		} else {
			normalVectorsRelativeAngle = 180 * (float) (Math.atan(Math.abs(dy) / Math.abs(dx)) / Math.PI);
		}

		return normalVectorsRelativeAngle;
	}

	/**
	 * Return the angle, relative to the positive x-axis, of a line that passes
	 * by (0, 0) and (dx, dy). The angle is calculated counter clockwise from
	 * positive x-axis, in degrees. The value can be between 0 and 359.
	 * 
	 * @param dx
	 *            The difference, on the x axis, between two x values.
	 * @param dy
	 *            The difference, on the y axis, between two y values.
	 * @return The angle, relative to the positive x-axis.
	 */
	private float getNormalVectorsAngle(float dx, float dy) {
		float normalVectorsAngle = 0;
		float normalVectorsRelativeAngle = getNormalVectorsRelativeAngle(dx, dy);

		// Then, find the initial value for the angle based on its quadrant
		// in a virtual geometrical plan.
		if (dx >= 0 && dy >= 0) {
			// 1st quadrant.
			normalVectorsAngle = 0 + normalVectorsRelativeAngle;
		} else if (dx < 0 && dy >= 0) {
			// 2nd quadrant.
			normalVectorsAngle = 180 - normalVectorsRelativeAngle;
		} else if (dx < 0 && dy < 0) {
			// 3rd quadrant.
			normalVectorsAngle = 180 + normalVectorsRelativeAngle;
		} else if (dx >= 0 && dy < 0) {
			// 4th quadrant.
			normalVectorsAngle = 360 - normalVectorsRelativeAngle;
		}

		return normalVectorsAngle;
	}

	/**
	 * Interface for the listener of a swipe event.
	 * 
	 * @author Laurianne Michaud, Simon Turcotte-Langevin
	 */
	public interface IOnSwipeListener {
		/**
		 * 
		 * @param event1
		 * @param event2
		 * @param velocityX
		 * @param velocityY
		 * @return
		 */
		public boolean onSwipe(MotionEvent event1, MotionEvent event2, float velocityX, float velocityY);
	}

	/**
	 * @return the leftToRightListener
	 */
	public IOnSwipeListener getLeftToRightListener() {
		return leftToRightListener;
	}

	/**
	 * @param leftToRightListener
	 *            the leftToRightListener to set
	 */
	public void setLeftToRightListener(IOnSwipeListener leftToRightListener) {
		this.leftToRightListener = leftToRightListener;
	}

	/**
	 * @return the rightToLeftListener
	 */
	public IOnSwipeListener getRightToLeftListener() {
		return rightToLeftListener;
	}

	/**
	 * @param rightToLeftListener
	 *            the rightToLeftListener to set
	 */
	public void setRightToLeftListener(IOnSwipeListener rightToLeftListener) {
		this.rightToLeftListener = rightToLeftListener;
	}

	/**
	 * @return the bottomToTopListener
	 */
	public IOnSwipeListener getBottomToTopListener() {
		return bottomToTopListener;
	}

	/**
	 * @param bottomToTopListener
	 *            the bottomToTopListener to set
	 */
	public void setBottomToTopListener(IOnSwipeListener bottomToTopListener) {
		this.bottomToTopListener = bottomToTopListener;
	}

	/**
	 * @return the topToBottomListener
	 */
	public IOnSwipeListener getTopToBottomListener() {
		return topToBottomListener;
	}

	/**
	 * @param topToBottomListener
	 *            the topToBottomListener to set
	 */
	public void setTopToBottomListener(IOnSwipeListener topToBottomListener) {
		this.topToBottomListener = topToBottomListener;
	}
}
